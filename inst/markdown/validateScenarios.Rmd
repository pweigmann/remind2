---
title: "validateScenarios"
author: "Pascal Weigmann"
date: "2023-12-12"
output:
  html_document: default
  pdf_document: default
---

```{r setup, echo=FALSE, message = FALSE, warning = FALSE}
library(quitte)
library(dplyr)
library(tidyr)
library(ggplot2)
library(ggthemes)
library(plotly)

knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
```


# TODO
DATA
 - data preparation depending on needed data
 - other categories
 - averaging, quick overview
 - support missing yellow/only min or max thresholds
PLOT
 - ordering of scenarios, years, regions
 - grouping of regions (currently causes layout problems)
 - detailed plots




# Import Data

For now: one or multiple ``REMIND_generic.mif`` + ``historical.mif``

In the future potentially: support ``quitte`` or ``fulldata.gdx``

```{r, cache = TRUE}
# from /p/tmp/pascalwe/ariadne/production/remind_23-09-28_ap_polishing_tech
data <- remind2::deletePlus(quitte::read.quitte(c("REMIND_generic_Bal.mif",
                                                  "REMIND_generic_NPi.mif")))
hist <- quitte::read.quitte("historical.mif")
head(data)
```

Load validation criteria from config file: ``validationConfig.csv``
```{r}
cfg <- read.csv2("validationConfig.csv", na.strings = "") %>% 
  mutate(max_red = as.numeric(max_red), max_yel = as.numeric(max_yel))

head(cfg)
```
# Engineer Data

```{r}
# full dimensions
all_reg <- unique(data$region)
all_per <- unique(data$period)
all_sce <- unique(data$scenario)
by <- c("variable", "region", "period", "scenario")

# additional dimension slices
hist_per <- c(2005, 2010, 2015, 2020)

# colors
colors <- c(green = "#008450", yellow = "#EFB700", red = "#B81D13")
```

## Cat1, Filter Data

Category 1: deviation to historical reference
- metric: absolute, relative
- ref_model:

```{r}
# category 1
d1 <- data.frame()
c1 <- cfg[cfg$category == 1, ]

# assemble data by row of cfg
for (i in 1:nrow(c1)) {
  # create filters
  # check whether regions, periods, scenarios are specified
  # TODO: extend to support excluding elements, multiple elements
  reg <- if (is.na(c1[i, "region"]))   all_reg else c1[i, "region"]
  per <- if (is.na(c1[i, "period"]))  hist_per else c1[i, "period"]
  sce <- if (is.na(c1[i, "scenario"])) all_sce else c1[i, "scenario"]
  
  # filter data for each row in cfg
  # run data for line i
  d <- data %>% 
  filter(variable == c1[i, "variable"], 
         region %in% reg,
         period %in% per,
         scenario %in% sce)
  
  # config data for line i
  c <- select(c1[i,], 
              c(variable, region, period, scenario, 
                min_red, min_yel, max_yel, max_red, ref_model))
  
  # historical data for line i
  h <- hist %>% 
  filter(variable == c1[i, "variable"], 
         region %in% reg,
         period %in% per) %>%
    mutate(ref_value = value) %>%
    select(-c("scenario", "unit", "value"))
  # remove NA here?

  
  # in case one or more sources are specified, filter for them
  if (!is.na(c$ref_model)) {
    h <- filter(h, model %in% strsplit(c$ref_model, split = ", ")[[1]])
  }
  
  # in case of multiple sources, calculate mean
  # TODO: support multiple regions
  if (length(unique(h$model)) > 1) {
    h_mean <- group_by(h, period) %>% 
      summarize(ref_value = mean(ref_value))
    h <- h_mean %>% 
      mutate(region = c$region, 
             variable = c$variable)
  }
  
  
  # Merge data
  # remove column names that have "NA" in cfg as they will not be used for merge
  # problem: different columns cause problems when combining data frames
  c <- c[ ,!is.na(c)]
  merge_cols <- colnames(c)[colnames(c) %in% by]
  
  # combine mif and cfg data
  d <- merge(d, c, by = merge_cols)
  
  # combine with historical values
  d <- merge(d, h,
             by.x = c(merge_cols,"period", "ref_model"), 
             by.y = c(merge_cols,"period", "model")) %>%
    mutate(ref_value = value.y, value = value.x) %>%
    select(-c(value.x, value.y))
  
  # make sure columns are the same in all cases
  d1 <- rbind(d1, d)
}

```


## Cat3, Filter Data

```{r}
# TODO
# - support "metric" = relative

# category 3
d3 <- data.frame()
c3 <- cfg[cfg$category == 3, ]

# assemble data by row of cfg
for (i in 1:nrow(c3)) {
  # create filters
  # check whether regions, periods, scenarios are specified
  # TODO: extend to support excluding elements, multiple elements
  reg <- if (is.na(c3[i, "region"]))   all_reg else c3[i, "region"]
  per <- if (is.na(c3[i, "period"]))   all_per else c3[i, "period"]
  sce <- if (is.na(c3[i, "scenario"])) all_sce else c3[i, "scenario"]
  
  # filter data for each row in cfg
  d <- data %>% 
  filter(variable == c3[i, "variable"], 
         region %in% reg,
         period %in% per,
         scenario %in% sce)
  c <- select(c3[i,], 
              c(variable, region, period, scenario, 
                min_red, min_yel, max_yel, max_red))
  # remove column names that have "NA" in cfg as they will not be used for merge
  c <- c[ ,!is.na(c)]
  merge_cols <- colnames(c)[colnames(c) %in% by]
  d <- merge(d, c, by=merge_cols)
  
  d3 <- rbind(d3, d)
}

```


## Duplicates

```{r}

d <- d3

# check for duplicates
# BEWARE: maybe sometimes duplicates are wanted?
# e.g. because regions have specific goals but also "all regions" have same goal
duplicates <- d[duplicated(d[c("variable", "region", "period", "scenario")]), ]
no_dupl <- anti_join(d, duplicates)

# overwrite "earlier" values using "later" ones 
# BEWARE: requires specific country to come after "all regions"
# alternative approach: go from "all regions" to spelling out goals for all regions,
# then individual countries could get higher priority over generic "all regions"
d <- merge(no_dupl, duplicates, by=c(by, "unit", "model", "value"), all.x = T) %>%
  mutate(min_red = ifelse(is.na(min_red.y), min_red.x, min_red.y)) %>%
  mutate(min_yel = ifelse(is.na(min_yel.y), min_yel.x, min_yel.y)) %>%
  mutate(max_yel = ifelse(is.na(max_yel.y), max_yel.x, max_yel.y)) %>%
  mutate(max_red = ifelse(is.na(max_red.y), max_red.x, max_red.y)) %>%
  select(-c("min_red.x", "min_yel.x", "max_yel.x", "max_red.x",
            "min_red.y", "min_yel.y", "max_yel.y", "max_red.y"))

```


# Evaluate

## Cat3, Evaluate
```{r}

# test whether values are above or below thresholds (Category 3)
d <- d %>% mutate(check = 
                        ifelse(
                          value > d$max_red | value < d$min_red, 
                          "red",
                          ifelse(
                            value > d$max_yel | value < d$min_yel, 
                            "yellow", 
                            "green"
                          )
                        )
                      )

```

# Plot

## Cat3, Results
Plot first results [jump here](#jump)

```{r}
# group regions (example)
mapping_reg <- data.frame(region = all_reg, group.reg = c(rep("region", 24), "World"))
d <- merge(d, mapping_reg, by = "region")

# x-axis interpreted as continuous, make discrete 
d$period <- as.character(d$period)
#colors <- c(green, yellow, red)

# new column: text for tooltip:
d <- d %>%
  mutate(text = paste0(region, "\n", 
                       period, "\n", 
                       "Value: ", round(value,2), "\n",
                       ifelse(period == "2030",
                              paste0("Min: ", d$min_yel, "/", d$min_red,"\n",
                                     "Max: ", d$max_yel, "/", d$max_red),
                              paste0("Min: ", d$min_yel, "/", d$min_red,"\n",
                                     "Max: ", d$max_yel, "/", d$max_red)
                              )
                       )
         )

# classic ggplot, with text in aes
p <- ggplot(d, aes(x = region, y = period, fill=check, text=text)) +
  geom_tile(color="white", linewidth=0.2) +
  scale_fill_manual(values = colors, breaks = colors) +
  facet_grid(scenario~.)
  # make it beautiful
  # from https://www.r-bloggers.com/2016/02/making-faceted-heatmaps-with-ggplot2/
p <- p + labs(x=NULL, y=NULL, title="Price|Carbon")
p <- p + theme_tufte()
p <- p + theme(axis.ticks=element_blank())
p <- p + theme(axis.text=element_text(size=7))
p <- p + coord_equal()
p <- p + theme(legend.position = "none")
# p + theme(panel.spacing = unit(2, "lines"))
p
fig <- ggplotly(p, tooltip="text")

# improve plotly layout, works but very manual
fig <- fig %>% subplot(heights = 0.3) %>%
    layout(title = list(y=0.64))
fig
p

```




Standalone Test

```{r, eval=FALSE}



# Dummy data
x <- LETTERS[1:10]
y <- paste0("var", seq(1,10))
data <- expand.grid(X=x, Y=y)
data$Z <- runif(100, 0, 1.5)
#data$Y1 <- cut(data$Z, breaks = c(-Inf,0.5,1,Inf), right = FALSE)

#breaks <- c("[-Inf,0.5)", "[0.5,1)", "[1,Inf)")
colors <- c("green", "yellow", "red")

# Create a vector of length 400 with random colors
random_colors_vector <- sample(colors, 100, replace = TRUE)
data$cols <- random_colors_vector

# new column: text for tooltip:
data <- data %>%
  mutate(text = paste0("x: ", X, "\n", "y: ", Y, "\n", "Value: ", round(Z,2), "\n", "What else?"))

# classic ggplot, with text in aes
p <- ggplot(data, aes(X, Y, fill= cols, text=text)) +
  geom_tile() +
  scale_fill_manual(values = colors, breaks = colors)

ggplotly(p, tooltip="text")
```

# Jump here {#jump}

More detailed results
