---
title: "validateScenarios"
author: "Pascal Weigmann"
date: "2023-12-12"
output:
  html_document:
    toc: true
    toc_float: true
---

```{r setup, echo=FALSE, message = FALSE, warning = FALSE}
library(quitte)
library(dplyr)
library(tidyr)
library(ggplot2)
library(ggthemes)
library(plotly)

knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
```


### TODO
DATA

 - [ ] robust data preparation for all kinds of config
 - [ ] categories 2, 4
 - [ ] averaging, quick overview
 - [ ] support missing yellow/only min or max thresholds
 - [ ] return data instead of plots
 - [ ] refactor to functions
 - [ ] avoid errors in case config refers to unavailable data, skip instead


PLOT

 - [ ] ordering of scenarios, years, regions
 - [ ] grouping of regions (currently causes layout problems)
 - [ ] detailed plots
 - [ ] clean interactive plot layout


### How-To validateScenario

**Cornerstones**

- input: one or multiple `REMIND_generic.mif`, one `historical.mif` and 
         one `validationConfig.csv`
- output: `validateScenarios.html`, an interactive Notebook
- output: data frame containing the information which elements failed or passed

**HTML Notebook**

- one plot per variable
- interactive plot gives all meta information that is necessary to understand
  why specific traffic light color is chosen

#### General Config Rules

- each set of thresholds (one value for each `min/max_yel/red`) gets one line 
  in the config
- later rows overwrite earlier rows (e.g. specifying a region after setting 
  thresholds for the same variable/time/scenario in all regions before)

columns `region`, `scenario` and `period`

- empty cells mean "all"
- enter one or multiple entries, separated by `,` (multiple not yet supported)

column `variable`

- cannot be empty
- only one entry allowed

#### Category Definitions

**Category 1: comparison to reference values**

Evaluate whether results deviate from a reference source 
(e.g. from historical.mif).

Relative deviation is defined as `abs(run_value - ref_value)/ref_value`.

required:

- `metric`: `absolute` (not supported yet) or `relative` (default)
- `max_red`: define strong threshold, enter desired value 
             (decimal for `relative`, e.g. `0.1` for `10%`)

optional:

- `ref_model`: specify one or multiple sources from the historical.mif the data 
               should be compared to. If empty, all available sources are used.
               If more than one source is chosen, their *mean* is used as 
               reference.
- `max_yel`: define a weaker threshold, otherwise same as `max_red`

**Category 2**

**Category 3**


required:

- `metric`: `absolute` (default) or `relative` (not supported yet)
- `max_red`: define strong threshold, enter desired value

optional:

- `min_red`: define a strong lower threshold, otherwise same as `max_red` (currently required)
- `min_yel`: define a weaker lower threshold, otherwise same as `max_red` (currently required)
- `max_yel`: define a weaker upper threshold, otherwise same as `max_red` (currently required)

**Category 4**


### Import Data

For now: one or multiple ``REMIND_generic.mif`` + ``historical.mif``

In the future potentially: support ``quitte`` or ``fulldata.gdx``

```{r, cache = TRUE}
# from /p/tmp/pascalwe/ariadne/production/remind_23-09-28_ap_polishing_tech
if (file.exists("mif.rds")) {
  data <- readRDS("mif.rds")
} else {
  data <- remind2::deletePlus(quitte::read.quitte(c("REMIND_generic_Bal.mif",
                                                  "REMIND_generic_NPi.mif")))
  saveRDS(data, "mif.rds")
}

if (file.exists("hist.rds")) {
  hist <- readRDS("hist.rds")
} else {
  hist <- quitte::read.quitte("historical.mif")
  saveRDS(hist, "hist.rds")
}

#data <- remind2::deletePlus(quitte::read.quitte(c("REMIND_generic_Bal.mif",
#                                                  "REMIND_generic_NPi.mif")))
#hist <- quitte::read.quitte("historical.mif")
head(data)
```

Load validation criteria from config file: ``validationConfig.csv``
```{r}
cfg <- read.csv2("validationConfig.csv", na.strings = "") %>% 
  mutate(max_red = as.numeric(max_red), max_yel = as.numeric(max_yel))

head(cfg)
```
### Engineer Data

```{r}
# dimensions of data
by <- c("variable", "region", "period", "scenario")

# full dimensions and important slices
all_reg <- unique(data$region)
all_per <- unique(data$period)  # not a factor, convert?
all_per <- all_per[all_per <= 2100]
hist_per <- c(2005, 2010, 2015, 2020)
all_sce <- unique(data$scenario)

# revert the sorting of factors for better plots
# data$region <- factor(data$region, levels = rev(levels(data$region)))

# define colors here or later
colors <- c(green = "#008450", yellow = "#EFB700", red = "#B81D13", grey = "#808080")
```

#### Cat1, Filter Data

Category 1: deviation to historical reference

- [ ] metric: absolute, relative

```{r}
# category 1
d1 <- data.frame()
c1 <- cfg[cfg$category == 1, ]

# assemble data by row of cfg
for (i in 1:nrow(c1)) {
  # create filters
  # check whether regions, periods, scenarios are specified
  # TODO: extend to support excluding elements, multiple elements
  reg <- if (is.na(c1[i, "region"]))   all_reg else strsplit(c1[i, "region"], split = ", |,")[[1]]
  per <- if (is.na(c1[i, "period"]))  hist_per else strsplit(as.character(c1[i, "period"]), split = ", |,")[[1]]
  sce <- if (is.na(c1[i, "scenario"])) all_sce else strsplit(c1[i, "scenario"], split = ", |, ")[[1]]
  
  # filter data for each row in cfg
  # REMIND data for line i
  d <- data %>% 
  filter(variable == c1[i, "variable"], 
         region %in% reg,
         period %in% per,
         scenario %in% sce)
  # here?: skip if empty
  
  # historical data for line i
  h <- hist %>% 
  filter(variable == c1[i, "variable"], 
         region %in% reg,
         period %in% per) %>%
    mutate(ref_value = value, ref_model = model) %>%
    select(-c("scenario", "unit", "value", "model"))
  # remove NA here?

  # in case one or more sources are specified, filter for them
  if (!is.na(c1[i, "ref_model"])) {
    h <- filter(h, ref_model %in% strsplit(c1[i, "ref_model"], split = ", |,")[[1]])
  }
  
  # in case of multiple sources, calculate mean (using all available sources)
  if (length(unique(h$ref_model)) > 1) {
    h_mean <- group_by(h, period, region) %>% 
      summarise(ref_value = mean(ref_value, na.rm = TRUE))
    h <- mutate(h_mean, variable = c1[i, "variable"], ref_model = "multiple")
  }
  
  # Merge REMIND, historical and config data
  d <- merge(d, h) %>%
    mutate(min_red = c1[i, ]$min_red,
           min_yel = c1[i, ]$min_yel,
           max_yel = c1[i, ]$max_yel,
           max_red = c1[i, ]$max_red)

  d1 <- rbind(d1, d)
}

head(d1)

```


#### Cat3, Filter Data

```{r}


# TODO
# - support "metric" = relative
# - remove "scenario" dimension? or at least show only one?

# category 3
d3 <- data.frame()
c3 <- cfg[cfg$category == 3, ]

# assemble data each row of the config at a time
for (i in 1:nrow(c3)) {
  # create filters: check whether regions, periods, scenarios are specified
  # split the string, in case multiple elements are given
  # TODO: extend to support excluding elements
  reg <- if (is.na(c3[i, "region"]))   all_reg else strsplit(c3[i, "region"], split = ", |,")[[1]]
  per <- if (is.na(c3[i, "period"]))   all_per else strsplit(as.character(c3[i, "period"]), split = ", |,")[[1]]
  sce <- if (is.na(c3[i, "scenario"])) all_sce else strsplit(c3[i, "scenario"], split = ", |, ")[[1]]
  
  # filter data for current row of config
  d <- data %>%
  filter(variable == c3[i, "variable"], # only one variable allowed per row
         region %in% reg,
         period %in% per,
         scenario %in% sce)
  
  # relevant config data
  # TODO: might not be necessary anymore
  c <- select(c3[i, ], 
              c(variable, region, period, scenario, 
                min_red, min_yel, max_yel, max_red))
  
  # attach thresholds to data slice
  d <- d %>%
    mutate(min_red = c3[i, ]$min_red,
           min_yel = c3[i, ]$min_yel,
           max_yel = c3[i, ]$max_yel,
           max_red = c3[i, ]$max_red)
  
  d3 <- rbind(d3, d)
}

head(d3)

```


#### Duplicates

```{r}
# Category 1

# check for duplicates
# BEWARE: maybe sometimes duplicates are wanted?
# e.g. because regions have specific goals but also "all regions" have same goal
duplicates <- d1[duplicated(d1[c("variable", "region", "period", "scenario", "ref_model")]), ]
no_dupl <- anti_join(d1, duplicates)

# overwrite "earlier" values using "later" ones 
# BEWARE: requires specific country to come after "all regions"
# alternative approach: go from "all regions" to spelling out goals for all regions,
# then individual countries could get higher priority over generic "all regions"
d1 <- merge(no_dupl, duplicates, by=c(by, "unit", "model", "value", 
                                     "ref_model", "ref_value"), 
           all.x = T) %>%
  mutate(min_red = ifelse(is.na(min_red.y), min_red.x, min_red.y)) %>%
  mutate(min_yel = ifelse(is.na(min_yel.y), min_yel.x, min_yel.y)) %>%
  mutate(max_yel = ifelse(is.na(max_yel.y), max_yel.x, max_yel.y)) %>%
  mutate(max_red = ifelse(is.na(max_red.y), max_red.x, max_red.y)) %>%
  select(-c("min_red.x", "min_yel.x", "max_yel.x", "max_red.x",
            "min_red.y", "min_yel.y", "max_yel.y", "max_red.y"))

# Category 3

# check for duplicates
# BEWARE: maybe sometimes duplicates are wanted?
# e.g. because regions have specific goals but also "all regions" have same goal
# TODO: fix if duplicates have same threshold values they are completely deleted
duplicates <- d3[duplicated(d3[c("variable", "region", "period", "scenario")]), ]
no_dupl <- anti_join(d3, duplicates)

# overwrite "earlier" values using "later" ones 
# BEWARE: requires specific country to come after "all regions"
# alternative approach: go from "all regions" to spelling out goals for all regions,
# then individual countries could get higher priority over generic "all regions"
d3 <- merge(no_dupl, duplicates, by=c(by, "unit", "model", "value"), 
            all.x = T) %>%
    mutate(min_red = ifelse(is.na(min_red.y), min_red.x, min_red.y)) %>%
    mutate(min_yel = ifelse(is.na(min_yel.y), min_yel.x, min_yel.y)) %>%
    mutate(max_yel = ifelse(is.na(max_yel.y), max_yel.x, max_yel.y)) %>%
    mutate(max_red = ifelse(is.na(max_red.y), max_red.x, max_red.y)) %>%
    select(-c("min_red.x", "min_yel.x", "max_yel.x", "max_red.x",
              "min_red.y", "min_yel.y", "max_yel.y", "max_red.y"))


```


### Evaluate Thresholds

#### Cat1, Evaluate

```{r}

# test whether values are above or below thresholds (Category 1)
# for now: "max" thresholds are interpreted as maximum deviation allowed
# above AND below reference value



d1 <- d1 %>% mutate(check = 
                      # check if reference is available
                      ifelse(is.na(ref_value), "grey",
                        ifelse(
                        # relative deviation above/below reference
                        abs((value-ref_value)/ref_value) > max_red,
                        "red",
                        # check if yellow threshold is given, else green
                        ifelse(!is.na(max_yel),
                          ifelse(
                            abs((value-ref_value)/ref_value) > max_yel,
                            "yellow", 
                            "green"),
                          "green"
                          )
                        )
                      )
                    )
```

#### Cat3, Evaluate
```{r}

# test whether values are above or below thresholds (Category 3)
# TODO make failproof for missing thresholds
d3 <- d3 %>% mutate(check = 
                        ifelse(
                          value > d3$max_red | value < d3$min_red, 
                          "red",
                          ifelse(
                            value > d3$max_yel | value < d3$min_yel, 
                            "yellow", 
                            "green"
                            )
                          )
                    )
```

### Plot

#### Category 1, Results
Test internal linking [jump here](#jump)

```{r}

source("plots_vs.R")


# group regions (example)
mapping_reg <- data.frame(region = all_reg, group.reg = c(rep("region", 24), "World"))
d <- merge(d, mapping_reg, by = "region")

# for (var in unique(d1$variable)) {
#   print(validationHeatmap(d1, var, cat = 3))
# }

validationHeatmap(d1, "Emi|CO2|Energy", cat = 1)
validationHeatmap(d1, "PE|Coal", cat = 1)
validationHeatmap(d1, "PE|Oil", cat = 1)
validationHeatmap(d1, "FE|Electricity", cat = 1)

```
#### Category 3, Results
Plot first results [jump here](#jump)

```{r}
# for (var in unique(d3$variable)) {
#   print(validationHeatmap(d3, var, cat = 3))
# }
validationHeatmap(d3, "Price|Carbon", cat = 3)
validationHeatmap(d3, "Emi|GHG", cat = 3)
```
#### Non-interactive results
Plot first results [jump here](#jump)

```{r}
validationHeatmap(d1, "Emi|CO2|Energy", cat = 1, interactive = F)
validationHeatmap(d1, "PE|Coal", cat = 1, interactive = F)
validationHeatmap(d1, "PE|Oil", cat = 1, interactive = F)
validationHeatmap(d3, "Price|Carbon", cat = 3, interactive = F)
```



### Jump here {#jump}

More detailed results
Standalone Test
```{r, eval=FALSE}



# Dummy data
x <- LETTERS[1:10]
y <- paste0("var", seq(1,10))
data <- expand.grid(X=x, Y=y)
data$Z <- runif(100, 0, 1.5)
#data$Y1 <- cut(data$Z, breaks = c(-Inf,0.5,1,Inf), right = FALSE)

#breaks <- c("[-Inf,0.5)", "[0.5,1)", "[1,Inf)")
colors <- c("green", "yellow", "red")

# Create a vector of length 400 with random colors
random_colors_vector <- sample(colors, 100, replace = TRUE)
data$cols <- random_colors_vector

# new column: text for tooltip:
data <- data %>%
  mutate(text = paste0("x: ", X, "\n", "y: ", Y, "\n", "Value: ", round(Z,2), "\n", "What else?"))

# classic ggplot, with text in aes
p <- ggplot(data, aes(X, Y, fill= cols, text=text)) +
  geom_tile() +
  scale_fill_manual(values = colors, breaks = colors)

ggplotly(p, tooltip="text")
p
```


