---
title: "validateScenarios"
author: "Pascal Weigmann"
date: "2023-12-12"
output:
  html_document:
    toc: true
    toc_float: true
---

```{r setup, echo=FALSE, message = FALSE, warning = FALSE}
library(quitte)
library(dplyr)
library(tidyr)
library(ggplot2)
library(ggthemes)
library(plotly)

knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
```


### Import Data

For now: one or multiple ``REMIND_generic.mif`` + ``historical.mif``

In the future potentially: support ``quitte`` or ``fulldata.gdx``

```{r, cache = TRUE}
# from /p/tmp/pascalwe/ariadne/production/remind_23-09-28_ap_polishing_tech
if (file.exists("mif.rds")) {
  data <- readRDS("mif.rds")
} else {
  data <- remind2::deletePlus(quitte::read.quitte(c("REMIND_generic_Bal.mif",
                                                  "REMIND_generic_NPi.mif")))
  saveRDS(data, "mif.rds")
}

if (file.exists("hist.rds")) {
  hist <- readRDS("hist.rds")
} else {
  hist <- quitte::read.quitte("historical.mif")
  saveRDS(hist, "hist.rds")
}

#data <- remind2::deletePlus(quitte::read.quitte(c("REMIND_generic_Bal.mif",
#                                                  "REMIND_generic_NPi.mif")))
#hist <- quitte::read.quitte("historical.mif")
head(data)
```

Load validation criteria from config file: ``validationConfig.csv``
```{r}
cfg <- read.csv2("validationConfig.csv", na.strings = "") %>% 
  mutate(max_red = as.numeric(max_red), max_yel = as.numeric(max_yel))

# fill empty threshold columns with Infinity
cfg <- cfg %>% mutate(min_red = ifelse(is.na(min_red), -Inf, min_red),
                      min_yel = ifelse(is.na(min_yel), -Inf, min_yel),
                      max_yel = ifelse(is.na(max_yel),  Inf, max_yel),
                      max_red = ifelse(is.na(max_red),  Inf, max_red))

head(cfg)
```

### Engineer Data

```{r}
# dimensions of data
by <- c("variable", "region", "period", "scenario")

# full dimensions and important slices
all_reg <- unique(data$region)
all_per <- unique(data$period)  # not a factor, convert?
all_per <- all_per[all_per <= 2100]
hist_per <- c(2005, 2010, 2015, 2020)
all_sce <- unique(data$scenario)

# revert the sorting of factors for better plots
# data$region <- factor(data$region, levels = rev(levels(data$region)))

# define colors here or later
colors <- c(green = "#008450", yellow = "#EFB700", red = "#B81D13", grey = "#808080")
```

#### Cat1, Filter Data

Category 1: deviation to historical reference

- [ ] metric: absolute, relative

```{r}
# category 1 data objects
d1 <- data.frame()
c1 <- cfg[cfg$category == 1, ]

# assemble data by row of cfg
for (i in 1:nrow(c1)) {
  # create filters
  # check whether regions, periods, scenarios are specified
  # TODO: extend to support excluding elements, multiple elements
  reg <- if (is.na(c1[i, "region"]))   all_reg else strsplit(c1[i, "region"], split = ", |,")[[1]]
  per <- if (is.na(c1[i, "period"]))  hist_per else strsplit(as.character(c1[i, "period"]), split = ", |,")[[1]]
  sce <- if (is.na(c1[i, "scenario"])) all_sce else strsplit(c1[i, "scenario"], split = ", |, ")[[1]]
  
  # filter data for each row in cfg
  # REMIND data for line i
  d <- data %>% 
  filter(variable == c1[i, "variable"], 
         region %in% reg,
         period %in% per,
         scenario %in% sce)
  # here?: skip if empty
  
  # historical data for line i
  h <- hist %>% 
  filter(variable == c1[i, "variable"], 
         region %in% reg,
         period %in% per) %>%
    mutate(ref_value = value, ref_model = model) %>%
    select(-c("scenario", "unit", "value", "model"))
  # remove NA here?

  # in case one or more sources are specified, filter for them
  if (!is.na(c1[i, "ref_model"])) {
    h <- filter(h, ref_model %in% strsplit(c1[i, "ref_model"], split = ", |,")[[1]])
  }
  
  # in case of multiple sources, calculate mean (using all available sources)
  if (length(unique(h$ref_model)) > 1) {
    h_mean <- group_by(h, period, region) %>% 
      summarise(ref_value = mean(ref_value, na.rm = TRUE))
    h <- mutate(h_mean, variable = c1[i, "variable"], ref_model = "multiple")
  }
  
  # Merge REMIND, historical and config data
  # (works as long as we only have one set of thresholds per cfg row)
  d <- merge(d, h) %>%
    mutate(min_red = c1[i, ]$min_red,
           min_yel = c1[i, ]$min_yel,
           max_yel = c1[i, ]$max_yel,
           max_red = c1[i, ]$max_red)

  d1 <- rbind(d1, d)
}

head(d1)

```


#### Cat2, Filter Data

```{r}
# TODO
# - support "metric" = relative
# - remove "scenario" dimension? or at least show only one?

# category 2 data objects
d2 <- data.frame()
c2 <- cfg[cfg$category == 2, ]

# assemble data each row of the config at a time
for (i in 1:nrow(c2)) {
  # create filters: check whether regions, periods, scenarios are specified
  # split the string, in case multiple elements are given
  # TODO: extend to support excluding elements
  reg <- if (is.na(c2[i, "region"]))   all_reg else strsplit(c2[i, "region"], split = ", |,")[[1]]
  per <- if (is.na(c2[i, "period"]))   all_per else strsplit(as.character(c2[i, "period"]), split = ", |,")[[1]]
  sce <- if (is.na(c2[i, "scenario"])) all_sce else strsplit(c2[i, "scenario"], split = ", |, ")[[1]]
  
  # filter data for current row of config
  d <- data %>%
  filter(variable == c2[i, "variable"], # only one variable allowed per row
         region %in% reg,
         period %in% per,
         scenario %in% sce)
  
  # attach thresholds to data slice
  # (works as long as we only have one set of thresholds per cfg row)
  d <- d %>%
    mutate(min_red = c2[i, ]$min_red,
           min_yel = c2[i, ]$min_yel,
           max_yel = c2[i, ]$max_yel,
           max_red = c2[i, ]$max_red)
  
  d2 <- rbind(d2, d)
}
```
#### Cat3, Filter Data

```{r}
# category 3 data objects
d3 <- data.frame()
c3 <- cfg[cfg$category == 3, ]

# assemble data each row of the config at a time
for (i in 1:nrow(c3)) {
  # create filters: check whether regions, periods, scenarios are specified
  # split the string, in case multiple elements are given
  # TODO? extend to support excluding elements
  reg <- if (is.na(c3[i, "region"]))   all_reg else strsplit(c3[i, "region"], split = ", |,")[[1]]
  per <- if (is.na(c3[i, "period"]))   all_per else strsplit(as.character(c3[i, "period"]), split = ", |,")[[1]]
  sce <- if (is.na(c3[i, "scenario"])) all_sce else strsplit(c3[i, "scenario"], split = ", |, ")[[1]]
  
  # filter data for current row of config
  d <- data %>%
  filter(variable == c3[i, "variable"], # only one variable allowed per row
         region %in% reg,
         period %in% per,
         scenario %in% sce)
  
  # attach thresholds to data slice 
  # (works as long as we only have one set of thresholds per cfg row)
  d <- d %>%
    mutate(min_red = c3[i, ]$min_red,
           min_yel = c3[i, ]$min_yel,
           max_yel = c3[i, ]$max_yel,
           max_red = c3[i, ]$max_red)
  
  d3 <- rbind(d3, d)
}
```

#### Duplicates

```{r}
# Category 1

# check for duplicates
# BEWARE: maybe sometimes duplicates are wanted?
# e.g. because regions have specific goals but also "all regions" have same goal
duplicates <- d1[duplicated(d1[c("variable", "region", "period", "scenario", "ref_model")]), ]
no_dupl <- anti_join(d1, duplicates)

# overwrite "earlier" values using "later" ones 
# BEWARE: requires specific country to come after "all regions"
# alternative approach: go from "all regions" to spelling out goals for all regions,
# then individual countries could get higher priority over generic "all regions"
d1 <- merge(no_dupl, duplicates, by=c(by, "unit", "model", "value", 
                                     "ref_model", "ref_value"), 
           all.x = T) %>%
  mutate(min_red = ifelse(is.na(min_red.y), min_red.x, min_red.y)) %>%
  mutate(min_yel = ifelse(is.na(min_yel.y), min_yel.x, min_yel.y)) %>%
  mutate(max_yel = ifelse(is.na(max_yel.y), max_yel.x, max_yel.y)) %>%
  mutate(max_red = ifelse(is.na(max_red.y), max_red.x, max_red.y)) %>%
  select(-c("min_red.x", "min_yel.x", "max_yel.x", "max_red.x",
            "min_red.y", "min_yel.y", "max_yel.y", "max_red.y"))

# category 2

# check for duplicates
# BEWARE: maybe sometimes duplicates are wanted?
# e.g. because regions have specific goals but also "all regions" have same goal
# TODO: fix if duplicates have same threshold values they are completely deleted
duplicates <- d2[duplicated(d2[c("variable", "region", "period", "scenario")]), ]
no_dupl <- anti_join(d2, duplicates)

# overwrite "earlier" values using "later" ones 
# BEWARE: requires specific country to come after "all regions"
# alternative approach: go from "all regions" to spelling out goals for all regions,
# then individual countries could get higher priority over generic "all regions"
d2 <- merge(no_dupl, duplicates, by=c(by, "unit", "model", "value"), 
            all.x = T) %>%
    mutate(min_red = ifelse(is.na(min_red.y), min_red.x, min_red.y)) %>%
    mutate(min_yel = ifelse(is.na(min_yel.y), min_yel.x, min_yel.y)) %>%
    mutate(max_yel = ifelse(is.na(max_yel.y), max_yel.x, max_yel.y)) %>%
    mutate(max_red = ifelse(is.na(max_red.y), max_red.x, max_red.y)) %>%
    select(-c("min_red.x", "min_yel.x", "max_yel.x", "max_red.x",
              "min_red.y", "min_yel.y", "max_yel.y", "max_red.y"))

# category 3

# check for duplicates
# BEWARE: maybe sometimes duplicates are wanted?
# e.g. because regions have specific goals but also "all regions" have same goal
# TODO: fix if duplicates have same threshold values they are completely deleted
duplicates <- d3[duplicated(d3[c("variable", "region", "period", "scenario")]), ]
no_dupl <- anti_join(d3, duplicates)

# overwrite "earlier" values using "later" ones 
# BEWARE: requires specific country to come after "all regions"
# alternative approach: go from "all regions" to spelling out goals for all regions,
# then individual countries could get higher priority over generic "all regions"
d3 <- merge(no_dupl, duplicates, by=c(by, "unit", "model", "value"), 
            all.x = T) %>%
    mutate(min_red = ifelse(is.na(min_red.y), min_red.x, min_red.y)) %>%
    mutate(min_yel = ifelse(is.na(min_yel.y), min_yel.x, min_yel.y)) %>%
    mutate(max_yel = ifelse(is.na(max_yel.y), max_yel.x, max_yel.y)) %>%
    mutate(max_red = ifelse(is.na(max_red.y), max_red.x, max_red.y)) %>%
    select(-c("min_red.x", "min_yel.x", "max_yel.x", "max_red.x",
              "min_red.y", "min_yel.y", "max_yel.y", "max_red.y"))

```


### Evaluate Thresholds

#### Cat1, Evaluate

```{r}

# test whether values are above or below thresholds (Category 1)
# for now: "max" thresholds are interpreted as maximum deviation allowed
# above AND below reference value
d1 <- d1 %>% mutate(check = 
                      # check if reference is available
                      ifelse(is.na(ref_value), "grey",
                        ifelse(
                        # relative deviation above/below reference, 
                        # first check whether red threshold is violated...
                        abs((value-ref_value)/ref_value) > max_red,
                        "red",
                        # otherwise check if yellow threshold is violated...
                          ifelse(
                            abs((value-ref_value)/ref_value) > max_yel,
                            "yellow",
                          # ... else green
                          "green"
                          )
                        )
                      )
                    )
```

#### Cat2, Evaluate
```{r}
# test whether values are above or below thresholds (category 2)
d2 <- d2 %>% mutate(check =
                        ifelse(
                          value > d2$max_red | value < d2$min_red,
                          "red",
                          ifelse(
                            value > d2$max_yel | value < d2$min_yel,
                            "yellow",
                            "green"
                            )
                          )
                    )
```


#### Cat3, Evaluate
```{r}
# calculate average growth rate of the last 5 years between 2010 and 2060
# TODO: in case of a need to look further than 2060, split df and add 
# calculations for 10-year step periods
d3 <- filter(d3, period <= 2060 & period >= 2010)

# add a column with the value 5 years ago for later calculations
d3_copy <- d3
d3$period <- d3$period + 5
d3 <- d3 %>% mutate(value_5y_ago = value) %>%
  select(-value) %>% merge(d3_copy)

# average growth rate
d3 <- d3 %>% 
  mutate(check_value = (value/value_5y_ago)^(1/5) - 1) %>% 
  mutate(check = ifelse(
                    check_value > d3$max_red | check_value < d3$min_red,
                    "red",
                    ifelse(
                      check_value > d3$max_yel | check_value < d3$min_yel,
                      "yellow",
                      "green"
                      )
                    )
              )
```

### Plot

#### Cat1, Results
Test internal linking [jump here](#jump)

```{r}
source("plots_vs.R")

# group regions (example)
mapping_reg <- data.frame(region = all_reg, group.reg = c(rep("region", 24), "World"))
d <- merge(d, mapping_reg, by = "region")

validationHeatmap(d1, "Emi|CO2|Energy", cat = 1)
validationHeatmap(d1, "PE|Coal", cat = 1)
validationHeatmap(d1, "PE|Oil", cat = 1)
validationHeatmap(d1, "FE|Electricity", cat = 1)

```

#### Cat2, Results

```{r}
validationHeatmap(d2, "Price|Carbon", cat = 2)
validationHeatmap(d2, "Emi|GHG", cat = 2)
```

#### Cat3, Results

```{r}
validationHeatmap(d3, "Cap|Electricity|Solar|PV", cat = 3)
```


#### Non-interactive results
Plot first results [jump here](#jump)

```{r}
validationHeatmap(d1, "Emi|CO2|Energy", cat = 1, interactive = F)
validationHeatmap(d1, "PE|Coal", cat = 1, interactive = F)
validationHeatmap(d1, "PE|Oil", cat = 1, interactive = F)
validationHeatmap(d2, "Price|Carbon", cat = 2, interactive = F)
```



### Jump here {#jump}

More detailed results
Standalone Test
```{r, eval=FALSE}



# Dummy data
x <- LETTERS[1:10]
y <- paste0("var", seq(1,10))
data <- expand.grid(X=x, Y=y)
data$Z <- runif(100, 0, 1.5)
#data$Y1 <- cut(data$Z, breaks = c(-Inf,0.5,1,Inf), right = FALSE)

#breaks <- c("[-Inf,0.5)", "[0.5,1)", "[1,Inf)")
colors <- c("green", "yellow", "red")

# Create a vector of length 400 with random colors
random_colors_vector <- sample(colors, 100, replace = TRUE)
data$cols <- random_colors_vector

# new column: text for tooltip:
data <- data %>%
  mutate(text = paste0("x: ", X, "\n", "y: ", Y, "\n", "Value: ", round(Z,2), "\n", "What else?"))

# classic ggplot, with text in aes
p <- ggplot(data, aes(X, Y, fill= cols, text=text)) +
  geom_tile() +
  scale_fill_manual(values = colors, breaks = colors)

ggplotly(p, tooltip="text")
p
```


