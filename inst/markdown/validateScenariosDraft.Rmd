---
title: "validateScenarios"
date: "2024-01-09"
output:
  html_document:
    toc: true
    toc_float: true
---

```{r setup, echo=FALSE, message = FALSE, warning = FALSE}
library(quitte)
library(dplyr)
library(tidyr)
library(ggplot2)
library(ggthemes)
library(plotly)

options(scipen = 20, digits = 2)
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, 
                      out.width='100%')
```

#### Import Data

For now: one or multiple `REMIND_generic.mif` + `historical.mif`

```{r, cache = TRUE}
# from /p/tmp/pascalwe/ariadne/production/remind_23-09-28_ap_polishing_tech
if (file.exists("mif.rds")) {
  data <- readRDS("mif.rds")
} else {
  data <- remind2::deletePlus(quitte::read.quitte(c("REMIND_generic_Bal.mif",
                                                  "REMIND_generic_NPi.mif")))
  saveRDS(data, "mif.rds")
}

if (file.exists("hist.rds")) {
  hist <- readRDS("hist.rds")
} else {
  hist <- quitte::read.quitte("historical.mif")
  saveRDS(hist, "hist.rds")
}


# change ordering of factors, put last element ("World") first
new_order <- c(tail(levels(data$region), 1), head(levels(data$region), -1))
data$region <- factor(data$region, levels = new_order)


#data <- remind2::deletePlus(quitte::read.quitte(c("REMIND_generic_Bal.mif",
#                                                  "REMIND_generic_NPi.mif")))
#hist <- quitte::read.quitte("historical.mif")
```

Load validation criteria from config file: `validationConfig.csv`

```{r}
cfg <- read.csv2("validationConfig.csv", na.strings = "")

# fill empty threshold columns with Infinity
cfg <- cfg %>% mutate(min_red = as.numeric(ifelse(is.na(min_red), -Inf, min_red)),
                      min_yel = as.numeric(ifelse(is.na(min_yel), -Inf, min_yel)),
                      max_yel = as.numeric(ifelse(is.na(max_yel),  Inf, max_yel)),
                      max_red = as.numeric(ifelse(is.na(max_red),  Inf, max_red))
                      )

#head(cfg)
```


```{r}
#### Engineer Data

# dimensions of data
by <- c("variable", "region", "period", "scenario")

# full dimensions and important slices
all_reg <- unique(data$region)
all_per <- unique(data$period)  # not a factor, convert?
all_per <- all_per[all_per <= 2100]
hist_per <- c(2005, 2010, 2015, 2020)
all_sce <- unique(data$scenario)

# revert the sorting of factors for better plots
# data$region <- factor(data$region, levels = rev(levels(data$region)))

# define colors here or later
colors <- c(green = "#008450", yellow = "#EFB700", red = "#B81D13", grey = "#808080")
```


```{r}
##### Cat1, Filter Data

# category 1 data objects
d1 <- data.frame()
c1 <- cfg[cfg$category == 1, ]

# assemble data by row of cfg
for (i in 1:nrow(c1)) {
  # create filters
  # check whether regions, periods, scenarios are specified
  # TODO: extend to support excluding elements, multiple elements
  reg <- if (is.na(c1[i, "region"]))   all_reg else strsplit(c1[i, "region"], split = ", |,")[[1]]
  per <- if (is.na(c1[i, "period"]))  hist_per else strsplit(as.character(c1[i, "period"]), split = ", |,")[[1]]
  sce <- if (is.na(c1[i, "scenario"])) all_sce else strsplit(c1[i, "scenario"], split = ", |, ")[[1]]
  
  # filter data for each row in cfg
  # REMIND data for line i
  d <- data %>% 
  filter(variable == c1[i, "variable"], 
         region %in% reg,
         period %in% per,
         scenario %in% sce)
  # here?: skip if empty
  
  # historical data for line i
  h <- hist %>% 
  filter(variable == c1[i, "variable"], 
         region %in% reg,
         period %in% per) %>%
    mutate(ref_value = value, ref_model = model) %>%
    select(-c("scenario", "unit", "value", "model"))
  # remove NA here?

  # in case one or more sources are specified, filter for them
  if (!is.na(c1[i, "ref_model"])) {
    h <- filter(h, ref_model %in% strsplit(c1[i, "ref_model"], split = ", |,")[[1]])
  }
  
  # in case of multiple sources, calculate mean (using all available sources)
  if (length(unique(h$ref_model)) > 1) {
    h_mean <- group_by(h, period, region) %>% 
      summarise(ref_value = mean(ref_value, na.rm = TRUE))
    h <- mutate(h_mean, variable = c1[i, "variable"], ref_model = "multiple")
  }
  
  # Merge REMIND, historical and config data
  # (works as long as we only have one set of thresholds per cfg row)
  d <- merge(d, h) %>%
    mutate(min_red = c1[i, ]$min_red,
           min_yel = c1[i, ]$min_yel,
           max_yel = c1[i, ]$max_yel,
           max_red = c1[i, ]$max_red,
           metric  = c1[i, ]$metric)

  d1 <- rbind(d1, d)
}

```


```{r}
##### Cat2, Filter Data

# TODO
# - support "metric" = relative
# - remove "scenario" dimension? or at least show only one?

# category 2 data objects
d2 <- data.frame()
c2 <- cfg[cfg$category == 2, ]

# assemble data each row of the config at a time
for (i in 1:nrow(c2)) {
  # create filters: check whether regions, periods, scenarios are specified
  # split the string, in case multiple elements are given
  # TODO: extend to support excluding elements
  reg <- if (is.na(c2[i, "region"]))   all_reg else strsplit(c2[i, "region"], split = ", |,")[[1]]
  per <- if (is.na(c2[i, "period"]))   all_per else strsplit(as.character(c2[i, "period"]), split = ", |,")[[1]]
  sce <- if (is.na(c2[i, "scenario"])) all_sce else strsplit(c2[i, "scenario"], split = ", |, ")[[1]]
  
  # filter data for current row of config
  d <- data %>%
  filter(variable == c2[i, "variable"], # only one variable allowed per row
         region %in% reg,
         period %in% per,
         scenario %in% sce)
  
  # in case of comparison to reference year, get ref data and merge
  if (c2[i, ]$metric == "relative") {
    ref <- data %>%
       filter(variable == c2[i, "variable"], # only one variable allowed per row
              region %in% reg,
              period == c2[i, ]$ref_period,
              scenario %in% sce) %>%
      mutate(ref_value = value) %>%
      select(-c(period, value))
    d <- merge(d, ref)
  } else {
    d <- mutate(d, ref_value = NA)
  }
  
  # attach thresholds to data slice
  # (works as long as we only have one set of thresholds per cfg row)
  d <- d %>%
    mutate(min_red = c2[i, ]$min_red,
           min_yel = c2[i, ]$min_yel,
           max_yel = c2[i, ]$max_yel,
           max_red = c2[i, ]$max_red,
           metric  = c2[i, ]$metric)
  
  if (c2[i, ]$metric != "absolute") {
    
  }
  
  d2 <- rbind(d2, d)
}
```


```{r}
##### Cat3, Filter Data

# category 3 data objects
d3 <- data.frame()
c3 <- cfg[cfg$category == 3, ]

# assemble data each row of the config at a time
for (i in 1:nrow(c3)) {
  # create filters: check whether regions, periods, scenarios are specified
  # split the string, in case multiple elements are given
  # TODO? extend to support excluding elements
  reg <- if (is.na(c3[i, "region"]))   all_reg else strsplit(c3[i, "region"], split = ", |,")[[1]]
  per <- if (is.na(c3[i, "period"]))   all_per else strsplit(as.character(c3[i, "period"]), split = ", |,")[[1]]
  sce <- if (is.na(c3[i, "scenario"])) all_sce else strsplit(c3[i, "scenario"], split = ", |, ")[[1]]
  
  # filter data for current row of config
  d <- data %>%
  filter(variable == c3[i, "variable"], # only one variable allowed per row
         region %in% reg,
         period %in% per,
         scenario %in% sce)
  
  # attach thresholds to data slice 
  # (works as long as we only have one set of thresholds per cfg row)
  d <- d %>%
    mutate(min_red = c3[i, ]$min_red,
           min_yel = c3[i, ]$min_yel,
           max_yel = c3[i, ]$max_yel,
           max_red = c3[i, ]$max_red,
           metric  = c3[i, ]$metric)
  
  d3 <- rbind(d3, d)
}
```


```{r}
##### Duplicates

# Category 1

# check for duplicates
# BEWARE: maybe sometimes duplicates are wanted?
# e.g. because regions have specific goals but also "all regions" have same goal
duplicates <- d1[duplicated(d1[c("variable", "region", "period", 
                                 "scenario", "ref_model", "metric")]), ]
no_dupl <- anti_join(d1, duplicates)

# overwrite "earlier" values using "later" ones 
# BEWARE: requires specific country to come after "all regions"
# alternative approach: go from "all regions" to spelling out goals for all regions,
# then individual countries could get higher priority over generic "all regions"
d1 <- merge(no_dupl, duplicates, by=c(by, "unit", "model", "value", 
                                     "ref_model", "ref_value", "metric"), 
           all.x = T) %>%
  mutate(min_red = ifelse(is.na(min_red.y), min_red.x, min_red.y)) %>%
  mutate(min_yel = ifelse(is.na(min_yel.y), min_yel.x, min_yel.y)) %>%
  mutate(max_yel = ifelse(is.na(max_yel.y), max_yel.x, max_yel.y)) %>%
  mutate(max_red = ifelse(is.na(max_red.y), max_red.x, max_red.y)) %>%
  select(-c("min_red.x", "min_yel.x", "max_yel.x", "max_red.x",
            "min_red.y", "min_yel.y", "max_yel.y", "max_red.y"))

# category 2

# check for duplicates
# BEWARE: maybe sometimes duplicates are wanted?
# e.g. because regions have specific goals but also "all regions" have same goal
# TODO: fix if duplicates have same threshold values they are completely deleted
duplicates <- d2[duplicated(d2[c("variable", "region", "period", 
                                 "scenario", "metric")]), ]
no_dupl <- anti_join(d2, duplicates)

# overwrite "earlier" values using "later" ones 
# BEWARE: requires specific country to come after "all regions"
# alternative approach: go from "all regions" to spelling out goals for all regions,
# then individual countries could get higher priority over generic "all regions"
d2 <- merge(no_dupl, duplicates, by=c(by, "unit", "model", "value", "metric", 
                                      "ref_value"), 
            all.x = T) %>%
    mutate(min_red = ifelse(is.na(min_red.y), min_red.x, min_red.y)) %>%
    mutate(min_yel = ifelse(is.na(min_yel.y), min_yel.x, min_yel.y)) %>%
    mutate(max_yel = ifelse(is.na(max_yel.y), max_yel.x, max_yel.y)) %>%
    mutate(max_red = ifelse(is.na(max_red.y), max_red.x, max_red.y)) %>%
    select(-c("min_red.x", "min_yel.x", "max_yel.x", "max_red.x",
              "min_red.y", "min_yel.y", "max_yel.y", "max_red.y"))

# category 3

# check for duplicates
# BEWARE: maybe sometimes duplicates are wanted?
# e.g. because regions have specific goals but also "all regions" have same goal
# TODO: fix if duplicates have same threshold values they are completely deleted
duplicates <- d3[duplicated(d3[c("variable", "region", "period", 
                                 "scenario", "metric")]), ]
no_dupl <- anti_join(d3, duplicates)

# overwrite "earlier" values using "later" ones 
# BEWARE: requires specific country to come after "all regions"
# alternative approach: go from "all regions" to spelling out goals for all regions,
# then individual countries could get higher priority over generic "all regions"
d3 <- merge(no_dupl, duplicates, by=c(by, "unit", "model", "value", "metric"), 
            all.x = T) %>%
    mutate(min_red = ifelse(is.na(min_red.y), min_red.x, min_red.y)) %>%
    mutate(min_yel = ifelse(is.na(min_yel.y), min_yel.x, min_yel.y)) %>%
    mutate(max_yel = ifelse(is.na(max_yel.y), max_yel.x, max_yel.y)) %>%
    mutate(max_red = ifelse(is.na(max_red.y), max_red.x, max_red.y)) %>%
    select(-c("min_red.x", "min_yel.x", "max_yel.x", "max_red.x",
              "min_red.y", "min_yel.y", "max_yel.y", "max_red.y"))

```



```{r}
#### Evaluate Thresholds

##### Cat1, Evaluate

# test whether values are above or below thresholds (Category 1)
# for now: "max" thresholds are interpreted as maximum deviation allowed
# above AND below reference value
d1 <- d1 %>%
  # calculate value that will be compared to thresholds
  mutate(check_value = ifelse(is.na(ref_value), NA,
                              ifelse(metric == "relative",
                                # relative deviation above/below reference
                                abs((value-ref_value)/ref_value),
                                # absolute deviation above/below reference
                                abs(value-ref_value)
                                )
                        )
         )  %>%
  # perform comparison to thresholds                           
  mutate(check = ifelse(is.na(check_value), "grey",
                    ifelse(
                    # first check whether red threshold is violated...
                    check_value > max_red,
                    "red",
                    # otherwise check if yellow threshold is violated...
                      ifelse(
                        check_value > max_yel,
                        "yellow",
                      # ... else green
                      "green"
                      )
                    )
                  )
                )
```


```{r}
##### Cat2, Evaluate

# test whether values are above or below thresholds (category 2)
d2 <- d2 %>%
  # calculate value that will be compared to thresholds
  mutate(check_value = ifelse(metric == "relative",
                              # relative deviation above/below reference
                              (value-ref_value)/ref_value,
                              # simply existing value
                              value
                              )
         )  %>%
  # check against thresholds
  mutate(check = ifelse(
                    check_value > max_red | check_value < min_red,
                    "red",
                    ifelse(
                      check_value > max_yel | check_value < min_yel,
                      "yellow",
                      "green"
                    )
                 )
         )
```


```{r}
##### Cat3, Evaluate

# calculate average growth rate of the last 5 years between 2010 and 2060
# TODO: in case of a need to look further than 2060, split df and add 
# calculations for 10-year step periods (move to filter data?)
d3 <- filter(d3, period <= 2050 & period >= 2010)

# add a column with the value 5 years ago for later calculations
d3_copy <- d3
d3$period <- d3$period + 5
d3 <- d3 %>% mutate(value_5y_ago = value) %>%
  select(-value) %>% merge(d3_copy)

# calculate and check the yearly average growth rate
d3 <- d3 %>% 
  mutate(check_value = (value/value_5y_ago)^(1/5) - 1) %>% 
  mutate(check = ifelse(
                    check_value > d3$max_red | check_value < d3$min_red,
                    "red",
                    ifelse(
                      check_value > d3$max_yel | check_value < d3$min_yel,
                      "yellow",
                      "green"
                      )
                    )
              )
```


```{r}
## Plot

# Prepare Plots
source("plots_vs.R")

# group regions (example)
# mapping_reg <- data.frame(region = all_reg, group.reg = c(rep("region", 24), "World"))
# d <- merge(d, mapping_reg, by = "region")

```



```{r}

### Summary

# Distribution of check results:
# 
# - Focus on overall run quality, very condensed.
# - No information about importance of variables.

# total amount of red/yellow/green/grey
cat1 <- data.frame(d1 %>% group_by(check) %>% summarise(c1 = n()))
cat2 <- data.frame(d2 %>% group_by(check) %>% summarise(c2 = n()))
cat3 <- data.frame(d3 %>% group_by(check) %>% summarise(c3 = n()))

cat_all <- merge(cat1, merge(cat2, cat3), all.x = T) %>%
  mutate(all = c1+c2+c3) %>%
  pivot_longer(cols = 2:5, names_to = "category")

cat_all[is.na(cat_all)] <- 0
cat_all <- group_by(cat_all, category) %>% mutate(frac = value/sum(value)) %>%
  pivot_longer(cols = c("value", "frac"), names_to = "metric", values_to = "val")

cat_all$check <- factor(cat_all$check,
                        levels = c("grey", "red","yellow", "green"),
                        ordered = T)

p <- ggplot(data=cat_all, aes(x=category, y=val, fill=check)) +
  geom_bar(stat="identity")+
  facet_wrap(metric~., scales="free") +
  scale_fill_manual(values = colors)
#ggplotly(p, tooltip="val")

```


```{r}
# Alternative Summary Idea: Treemaps
# 
# - Focus on how many checks failed and which variable failed most.
# - No information about importance of variables.


library(treemap)
# treemap for red
cat1 <- data.frame(d1 %>% group_by(check, variable) %>% summarise(n())) %>%
  filter(check == "red") %>% mutate(cat = 1)
cat2 <- data.frame(d2 %>% group_by(check, variable) %>% summarise(n())) %>%
  filter(check == "red") %>% mutate(cat = 2)
cat3 <- data.frame(d3 %>% group_by(check, variable) %>% summarise(n())) %>%
  filter(check == "red") %>% mutate(cat = 3)

cat_all <- rbind(cat1, cat2, cat3)

# treemap(cat_all, index=c("cat", "variable"),
#         vSize="n..", title = "Number of `red` in each category and variable")


cat1 <- data.frame(d1 %>% group_by(check, variable) %>% summarise(n()))


# treemap(cat1, index=c("check", "variable"),
#         vSize="n..", title = "Counting all check outcomes in Category 1",
#         palette = colors, fontsize.labels=c(0,12),)
  
```


### Comparison to Reference Values

Evaluate whether results deviate from a reference source 
(from historical.mif or same variable from another scenario(not supported yet)).

Relative deviation is defined as `abs(run_value - ref_value)/ref_value`.

required:

- `metric`: `absolute` or `relative` (default)
- at least one threshold, e.g. `max_red`: define strong threshold, enter desired
  value (decimal for `relative`, e.g. `0.1` for `10%`)

optional:

- `ref_model`: specify one or multiple sources from the historical.mif the data 
               should be compared to.
- `max_yel`: define a weaker threshold, besides `max_red`

```{r}
validationHeatmap(d1, "PE|Oil", cat = 1)
validationHeatmap(d1, "PE|Coal", cat = 1)
validationHeatmap(d1, "FE|Electricity", cat = 1)
validationHeatmap(d1, "Emi|CO2|Energy", cat = 1)

```

### Target Values (aka. Expert Guesses)

Check whether variables are above or below absolute or relative thresholds (relative to value from
a reference year).

required:

- `metric`: `absolute` (default) or `relative`. Default reference year
  is 2020.
- at least one of `min_red`, `min_yel`, `max_yel` or `max_red`


```{r}
validationHeatmap(d2, "Price|Carbon", cat = 2)

validationHeatmap(d2, "Price|Secondary Energy|Electricity", cat = 2)

validationHeatmap(d2, "FE", cat = 2)

validationHeatmap(d2, "Emi|GHG", cat = 2)

validationHeatmap(d2, "Emi|CO2", cat = 2)

validationHeatmap(d2, "Temperature|Global Mean", cat = 2)
```

### Growth Rates

Check average yearly growth rates (average of the last 5 years).

```{r}
validationHeatmap(d3, "Cap|Electricity|Solar|PV", cat = 3)
```


